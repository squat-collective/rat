// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: runs.sql

package gen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createRun = `-- name: CreateRun :one
INSERT INTO runs (pipeline_id, status, trigger)
VALUES ($1, $2, $3)
RETURNING id, pipeline_id, status, trigger, started_at, finished_at,
          duration_ms, rows_written, error, logs_s3_path, created_at
`

type CreateRunParams struct {
	PipelineID uuid.UUID
	Status     string
	Trigger    string
}

type CreateRunRow struct {
	ID          uuid.UUID
	PipelineID  uuid.UUID
	Status      string
	Trigger     string
	StartedAt   *time.Time
	FinishedAt  *time.Time
	DurationMs  pgtype.Int4
	RowsWritten pgtype.Int8
	Error       pgtype.Text
	LogsS3Path  pgtype.Text
	CreatedAt   time.Time
}

func (q *Queries) CreateRun(ctx context.Context, arg CreateRunParams) (CreateRunRow, error) {
	row := q.db.QueryRow(ctx, createRun, arg.PipelineID, arg.Status, arg.Trigger)
	var i CreateRunRow
	err := row.Scan(
		&i.ID,
		&i.PipelineID,
		&i.Status,
		&i.Trigger,
		&i.StartedAt,
		&i.FinishedAt,
		&i.DurationMs,
		&i.RowsWritten,
		&i.Error,
		&i.LogsS3Path,
		&i.CreatedAt,
	)
	return i, err
}

const getRun = `-- name: GetRun :one
SELECT id, pipeline_id, status, trigger, started_at, finished_at,
       duration_ms, rows_written, error, logs_s3_path, created_at
FROM runs
WHERE id = $1
`

type GetRunRow struct {
	ID          uuid.UUID
	PipelineID  uuid.UUID
	Status      string
	Trigger     string
	StartedAt   *time.Time
	FinishedAt  *time.Time
	DurationMs  pgtype.Int4
	RowsWritten pgtype.Int8
	Error       pgtype.Text
	LogsS3Path  pgtype.Text
	CreatedAt   time.Time
}

func (q *Queries) GetRun(ctx context.Context, id uuid.UUID) (GetRunRow, error) {
	row := q.db.QueryRow(ctx, getRun, id)
	var i GetRunRow
	err := row.Scan(
		&i.ID,
		&i.PipelineID,
		&i.Status,
		&i.Trigger,
		&i.StartedAt,
		&i.FinishedAt,
		&i.DurationMs,
		&i.RowsWritten,
		&i.Error,
		&i.LogsS3Path,
		&i.CreatedAt,
	)
	return i, err
}

const getRunLogsByID = `-- name: GetRunLogsByID :one
SELECT logs FROM runs WHERE id = $1
`

func (q *Queries) GetRunLogsByID(ctx context.Context, id uuid.UUID) ([]byte, error) {
	row := q.db.QueryRow(ctx, getRunLogsByID, id)
	var logs []byte
	err := row.Scan(&logs)
	return logs, err
}

const listRuns = `-- name: ListRuns :many
SELECT r.id, r.pipeline_id, r.status, r.trigger, r.started_at, r.finished_at,
       r.duration_ms, r.rows_written, r.error, r.logs_s3_path, r.created_at
FROM runs r
JOIN pipelines p ON r.pipeline_id = p.id
WHERE ($1::text IS NULL OR p.namespace = $1)
  AND ($2::text IS NULL OR p.layer = $2)
  AND ($3::text IS NULL OR p.name = $3)
  AND ($4::text IS NULL OR r.status = $4)
ORDER BY r.created_at DESC
`

type ListRunsParams struct {
	FilterNamespace pgtype.Text
	FilterLayer     pgtype.Text
	FilterPipeline  pgtype.Text
	FilterStatus    pgtype.Text
}

type ListRunsRow struct {
	ID          uuid.UUID
	PipelineID  uuid.UUID
	Status      string
	Trigger     string
	StartedAt   *time.Time
	FinishedAt  *time.Time
	DurationMs  pgtype.Int4
	RowsWritten pgtype.Int8
	Error       pgtype.Text
	LogsS3Path  pgtype.Text
	CreatedAt   time.Time
}

func (q *Queries) ListRuns(ctx context.Context, arg ListRunsParams) ([]ListRunsRow, error) {
	rows, err := q.db.Query(ctx, listRuns,
		arg.FilterNamespace,
		arg.FilterLayer,
		arg.FilterPipeline,
		arg.FilterStatus,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRunsRow{}
	for rows.Next() {
		var i ListRunsRow
		if err := rows.Scan(
			&i.ID,
			&i.PipelineID,
			&i.Status,
			&i.Trigger,
			&i.StartedAt,
			&i.FinishedAt,
			&i.DurationMs,
			&i.RowsWritten,
			&i.Error,
			&i.LogsS3Path,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveRunLogs = `-- name: SaveRunLogs :exec
UPDATE runs SET logs = $1 WHERE id = $2
`

type SaveRunLogsParams struct {
	Logs []byte
	ID   uuid.UUID
}

func (q *Queries) SaveRunLogs(ctx context.Context, arg SaveRunLogsParams) error {
	_, err := q.db.Exec(ctx, saveRunLogs, arg.Logs, arg.ID)
	return err
}

const updateRunStatus = `-- name: UpdateRunStatus :exec
UPDATE runs
SET status = $1::varchar(20),
    error = $2,
    started_at = CASE
        WHEN $1::varchar(20) = 'running' AND started_at IS NULL THEN now()
        ELSE started_at
    END,
    finished_at = CASE
        WHEN $1::varchar(20) IN ('success', 'failed', 'cancelled') THEN now()
        ELSE finished_at
    END,
    duration_ms = CASE
        WHEN $3::int IS NOT NULL THEN $3::int
        WHEN $1::varchar(20) IN ('success', 'failed', 'cancelled') AND started_at IS NOT NULL
        THEN EXTRACT(EPOCH FROM (now() - started_at))::int * 1000
        ELSE duration_ms
    END,
    rows_written = CASE
        WHEN $4::bigint IS NOT NULL THEN $4::bigint
        ELSE rows_written
    END
WHERE id = $5
`

type UpdateRunStatusParams struct {
	Status      string
	Error       pgtype.Text
	DurationMs  pgtype.Int4
	RowsWritten pgtype.Int8
	ID          uuid.UUID
}

func (q *Queries) UpdateRunStatus(ctx context.Context, arg UpdateRunStatusParams) error {
	_, err := q.db.Exec(ctx, updateRunStatus,
		arg.Status,
		arg.Error,
		arg.DurationMs,
		arg.RowsWritten,
		arg.ID,
	)
	return err
}
