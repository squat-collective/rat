// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: landing_zones.sql

package gen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createLandingFile = `-- name: CreateLandingFile :one
INSERT INTO landing_files (zone_id, filename, s3_path, size_bytes, content_type, uploaded_by)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, zone_id, filename, s3_path, size_bytes, content_type, uploaded_by, uploaded_at
`

type CreateLandingFileParams struct {
	ZoneID      uuid.UUID
	Filename    string
	S3Path      string
	SizeBytes   int64
	ContentType string
	UploadedBy  pgtype.Text
}

func (q *Queries) CreateLandingFile(ctx context.Context, arg CreateLandingFileParams) (LandingFile, error) {
	row := q.db.QueryRow(ctx, createLandingFile,
		arg.ZoneID,
		arg.Filename,
		arg.S3Path,
		arg.SizeBytes,
		arg.ContentType,
		arg.UploadedBy,
	)
	var i LandingFile
	err := row.Scan(
		&i.ID,
		&i.ZoneID,
		&i.Filename,
		&i.S3Path,
		&i.SizeBytes,
		&i.ContentType,
		&i.UploadedBy,
		&i.UploadedAt,
	)
	return i, err
}

const createLandingZone = `-- name: CreateLandingZone :one
INSERT INTO landing_zones (namespace, name, description, owner)
VALUES ($1, $2, $3, $4)
RETURNING id, namespace, name, description, owner, expected_schema, created_at, updated_at
`

type CreateLandingZoneParams struct {
	Namespace   string
	Name        string
	Description string
	Owner       pgtype.Text
}

type CreateLandingZoneRow struct {
	ID             uuid.UUID
	Namespace      string
	Name           string
	Description    string
	Owner          pgtype.Text
	ExpectedSchema string
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) CreateLandingZone(ctx context.Context, arg CreateLandingZoneParams) (CreateLandingZoneRow, error) {
	row := q.db.QueryRow(ctx, createLandingZone,
		arg.Namespace,
		arg.Name,
		arg.Description,
		arg.Owner,
	)
	var i CreateLandingZoneRow
	err := row.Scan(
		&i.ID,
		&i.Namespace,
		&i.Name,
		&i.Description,
		&i.Owner,
		&i.ExpectedSchema,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLandingFile = `-- name: DeleteLandingFile :exec
DELETE FROM landing_files
WHERE id = $1
`

func (q *Queries) DeleteLandingFile(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteLandingFile, id)
	return err
}

const deleteLandingZone = `-- name: DeleteLandingZone :exec
DELETE FROM landing_zones
WHERE namespace = $1 AND name = $2
`

type DeleteLandingZoneParams struct {
	Namespace string
	Name      string
}

func (q *Queries) DeleteLandingZone(ctx context.Context, arg DeleteLandingZoneParams) error {
	_, err := q.db.Exec(ctx, deleteLandingZone, arg.Namespace, arg.Name)
	return err
}

const getLandingFile = `-- name: GetLandingFile :one
SELECT id, zone_id, filename, s3_path, size_bytes, content_type, uploaded_by, uploaded_at
FROM landing_files
WHERE id = $1
`

func (q *Queries) GetLandingFile(ctx context.Context, id uuid.UUID) (LandingFile, error) {
	row := q.db.QueryRow(ctx, getLandingFile, id)
	var i LandingFile
	err := row.Scan(
		&i.ID,
		&i.ZoneID,
		&i.Filename,
		&i.S3Path,
		&i.SizeBytes,
		&i.ContentType,
		&i.UploadedBy,
		&i.UploadedAt,
	)
	return i, err
}

const getLandingZone = `-- name: GetLandingZone :one
SELECT lz.id, lz.namespace, lz.name, lz.description, lz.owner, lz.expected_schema,
       lz.created_at, lz.updated_at,
       COALESCE(COUNT(lf.id), 0)::bigint AS file_count,
       COALESCE(SUM(lf.size_bytes), 0)::bigint AS total_bytes
FROM landing_zones lz
LEFT JOIN landing_files lf ON lf.zone_id = lz.id
WHERE lz.namespace = $1 AND lz.name = $2
GROUP BY lz.id
`

type GetLandingZoneParams struct {
	Namespace string
	Name      string
}

type GetLandingZoneRow struct {
	ID             uuid.UUID
	Namespace      string
	Name           string
	Description    string
	Owner          pgtype.Text
	ExpectedSchema string
	CreatedAt      time.Time
	UpdatedAt      time.Time
	FileCount      int64
	TotalBytes     int64
}

func (q *Queries) GetLandingZone(ctx context.Context, arg GetLandingZoneParams) (GetLandingZoneRow, error) {
	row := q.db.QueryRow(ctx, getLandingZone, arg.Namespace, arg.Name)
	var i GetLandingZoneRow
	err := row.Scan(
		&i.ID,
		&i.Namespace,
		&i.Name,
		&i.Description,
		&i.Owner,
		&i.ExpectedSchema,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FileCount,
		&i.TotalBytes,
	)
	return i, err
}

const getLandingZoneByID = `-- name: GetLandingZoneByID :one
SELECT id, namespace, name, description, owner, expected_schema, created_at, updated_at
FROM landing_zones
WHERE id = $1
`

type GetLandingZoneByIDRow struct {
	ID             uuid.UUID
	Namespace      string
	Name           string
	Description    string
	Owner          pgtype.Text
	ExpectedSchema string
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) GetLandingZoneByID(ctx context.Context, id uuid.UUID) (GetLandingZoneByIDRow, error) {
	row := q.db.QueryRow(ctx, getLandingZoneByID, id)
	var i GetLandingZoneByIDRow
	err := row.Scan(
		&i.ID,
		&i.Namespace,
		&i.Name,
		&i.Description,
		&i.Owner,
		&i.ExpectedSchema,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLandingFiles = `-- name: ListLandingFiles :many
SELECT id, zone_id, filename, s3_path, size_bytes, content_type, uploaded_by, uploaded_at
FROM landing_files
WHERE zone_id = $1
ORDER BY uploaded_at DESC
`

func (q *Queries) ListLandingFiles(ctx context.Context, zoneID uuid.UUID) ([]LandingFile, error) {
	rows, err := q.db.Query(ctx, listLandingFiles, zoneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LandingFile{}
	for rows.Next() {
		var i LandingFile
		if err := rows.Scan(
			&i.ID,
			&i.ZoneID,
			&i.Filename,
			&i.S3Path,
			&i.SizeBytes,
			&i.ContentType,
			&i.UploadedBy,
			&i.UploadedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLandingZones = `-- name: ListLandingZones :many
SELECT lz.id, lz.namespace, lz.name, lz.description, lz.owner, lz.expected_schema,
       lz.created_at, lz.updated_at,
       COALESCE(COUNT(lf.id), 0)::bigint AS file_count,
       COALESCE(SUM(lf.size_bytes), 0)::bigint AS total_bytes
FROM landing_zones lz
LEFT JOIN landing_files lf ON lf.zone_id = lz.id
WHERE ($1::text IS NULL OR lz.namespace = $1)
GROUP BY lz.id
ORDER BY lz.created_at DESC
`

type ListLandingZonesRow struct {
	ID             uuid.UUID
	Namespace      string
	Name           string
	Description    string
	Owner          pgtype.Text
	ExpectedSchema string
	CreatedAt      time.Time
	UpdatedAt      time.Time
	FileCount      int64
	TotalBytes     int64
}

func (q *Queries) ListLandingZones(ctx context.Context, filterNamespace pgtype.Text) ([]ListLandingZonesRow, error) {
	rows, err := q.db.Query(ctx, listLandingZones, filterNamespace)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLandingZonesRow{}
	for rows.Next() {
		var i ListLandingZonesRow
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Name,
			&i.Description,
			&i.Owner,
			&i.ExpectedSchema,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FileCount,
			&i.TotalBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLandingZone = `-- name: UpdateLandingZone :one
UPDATE landing_zones
SET description = COALESCE($3, description),
    owner = COALESCE($4, owner),
    expected_schema = COALESCE($5, expected_schema),
    updated_at = NOW()
WHERE namespace = $1 AND name = $2
RETURNING id, namespace, name, description, owner, expected_schema, created_at, updated_at
`

type UpdateLandingZoneParams struct {
	Namespace      string
	Name           string
	Description    pgtype.Text
	Owner          pgtype.Text
	ExpectedSchema pgtype.Text
}

type UpdateLandingZoneRow struct {
	ID             uuid.UUID
	Namespace      string
	Name           string
	Description    string
	Owner          pgtype.Text
	ExpectedSchema string
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) UpdateLandingZone(ctx context.Context, arg UpdateLandingZoneParams) (UpdateLandingZoneRow, error) {
	row := q.db.QueryRow(ctx, updateLandingZone,
		arg.Namespace,
		arg.Name,
		arg.Description,
		arg.Owner,
		arg.ExpectedSchema,
	)
	var i UpdateLandingZoneRow
	err := row.Scan(
		&i.ID,
		&i.Namespace,
		&i.Name,
		&i.Description,
		&i.Owner,
		&i.ExpectedSchema,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
